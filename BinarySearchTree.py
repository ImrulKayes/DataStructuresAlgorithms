# Definition for a binary tree node.class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass BSTIterator:    # @param root, a binary search tree's root node    def __init__(self, root):        self.lists=self.printSortedTree(root)        self.nextToGo=0    def hasNext(self):        if self.nextToGo>len(self.lists)-1:            return False        else:            return True            def next(self):        toGo=self.lists[self.nextToGo]        self.nextToGo+=1        return toGo    def printSortedTree(self,root):        # very intuitive, binary tree inorder traversal        if root is None:            return []        else:            return self.printSortedTree(root.left)+[root.val]+self.printSortedTree(root.right)class BTree1:    def __init__(self):        self.root=None    def insertNode(self,val):        newNode=TreeNode(val)        root=self.root        if root==None:            self.root=newNode            return        else:            current=root            while True:                if val<=current.val:                    if not current.left:                        current.left=TreeNode(val)                        return                     else:                        current=current.left                else:                    if not current.right:                        current.right=TreeNode(val)                        return                     else:                        current=current.right    def insert(self,root,data):        if not root:            return Node(data)        else:            if data<=root.data:                root.left=self.insert(root.left,data)            else:                root.right=self.insert(root.right,data)        return root                            def printTree(self,root):        if root is None:            return        else:            print root.val            self.printTree(root.left)            self.printTree(root.right)    def printSortedTree(self,root):        if root is None:            return []        else:            lists=self.printSortedTree(root.left)            lists.append(root.val)            lists2=self.printSortedTree(root.right)            return lists+lists2    def returnRoot(self):        return self.root    def isValidBST1(self, root):        # very intuitive, binary tree inorder traversal, using stack, other two ways are below        #1) Create an empty stack S.        #2) Initialize current node as root        #3) Push the current node to S and set current = current->left until current is NULL        #4) If current is NULL and stack is not empty then         #a) Pop the top item from stack.        #b) Print the popped item, set current = popped_item->right         #c) Go to step 3.        #5) If current is NULL and stack is empty then we are done.        stack = []        nodes = []                while True:          while root:            stack.append(root)            root = root.left          if not stack:            return True          right_root = stack.pop()          if nodes and right_root.val <= nodes.pop():            return False          nodes.append(right_root.val)          root = right_root.right              def printSortedTree(self,root):        if root is None:            return []        else:            lists=self.printSortedTree(root.left)            lists.append(root.val)            lists2=self.printSortedTree(root.right)            return lists+lists2                def isValidBST(self, root):        # cheating a bit. We know that in-order traversal of a BST gives sorted order. If we don't get that then no BST        # or an elegeant solution is below        if root==None:            return True        lists=self.printSortedTree(root)        print lists        for i in range(1,len(lists)):            if int(lists[i-1])>=int(lists[i]):                return False        return True        def isValidBST(self, root, lessThan = float('inf'), largerThan = float('-inf')):     #Pass down two parameters: lessThan (which means that all nodes in the the current subtree must be smaller than this value) and largerThan (all must be larger than it).     #Compare root of the current subtree with these two values. Then, recursively check the left and right subtree of the current one.         if not root:            return True        if root.val <= largerThan or root.val >= lessThan:            return False        return self.isValidBST(root.left, root.val, largerThan) and \               self.isValidBST(root.right, lessThan, root.val)    def inorder(self,root):        if not root:            return []        return self.inorder(root.left)+[root.val]+self.inorder(root.right)    def kthSmallest(self, root, k):        # inorder traversals gives the sorted order. So, kth smallest is the k-1 th element in the inorder list        # another solution is below        if not root:            return None        nums=self.inorder(root)        return nums[k-1]    def kthSmallest(self, root, k):        # a solution using no extra varible is below        number=[0] # for result        count=[k] # count         self.kthSmallestHelper(root,count,number)        return number[0]        def kthSmallestHelper(self,root,count,number):        if root.left:            self.kthSmallestHelper(root.left,count,number)                    count[0]-=1        if count[0]==0:            number[0]=root.val            return        if root.right:            self.kthSmallestHelper(root.right,count,number)    def kthSmallest(self, root, k):        return self.kthSmallestHelper(root,[k])        def kthSmallestHelper(self, root, k):        if not root:            return -1        val=self.kthSmallestHelper(root.left,k)        # if val is not -1 then we have found it, just return that        if val!=-1:            return val        k[0]-=1        if k[0]==0:            return root.val        return self.kthSmallestHelper(root.right,k)    def numTrees1(self, n):        # if for [1,2,3,4,5], if we consider 3 a root then #BST([1,2])*BST([4,5]) are total BSTs having 3 as root. we can do this for all numbers and sum        # we are doing counting trees multiple times. A memoization solution is below also a complex dynamic solution is below        if n<=1:            return 1        count=0        for i in range(1,n+1):            # e.g., if n=4 and i=2 then trees(1)*trees(2) are total trees possible having 2 as root            count+=self.numTrees1(i-1)*self.numTrees1(n-i)        return count    def numTrees2(self,n):        # time complexity O(n**2), for each n we are doing O(n) work        nums=[None for i in range(n+1)]        return self.numTreesUtil(n,nums)        def numTreesUtil(self,n,nums):        if n<=1:            return 1        count=0                for i in range(1,n+1):            if not nums[i-1]:                nums[i-1]=self.numTreesUtil(i-1,nums)            if not nums[n-i]:                nums[n-i]=self.numTreesUtil(n-i,nums)            count+=nums[i-1]*nums[n-i]        return count    def numTrees(self, n):        # DP, e.g., if for [1,2,3,4,5], if we consider 3 a root then #BST([1,2])*BST([4,5]) are total BSTs having 3 as root. we can do this for all numbers and sum        # G(n): the number of unique BST for a sequence of length n.        # F(i, n), 1 <= i <= n: the number of unique BST, where the number i is the root of BST, and the sequence ranges from 1 to n.        # G(n) = F(1, n) + F(2, n) + ... + F(n, n). G(0)=1, G(1)=1.        # F(i, n) = G(i-1) * G(n-i)   1 <= i <= n                G=[0 for i in range(n+1)]        G[0],G[1]=1,1        for i in range(2,n+1):            # all possible combination of left and right and sum            for j in range(1,i+1):                G[i]+=G[j-1]*G[i-j]        return G[n]    def generateTrees(self, n):        # it uses the same concept from numTrees        # if for [1,2,3,4,5], if we consider 3 a root then, roots from(BST([1,2]))*root and from (BST([4,5]))*root are possible left and right children of current root. we can do this for all numbers and retrun the root        # note that we can use DP, as the recursion is doing some stuffs again and again (e.g, BST([4,5]) needs to do when considering 1,2,3 as roots), but that would be some pain :(        if n==0: return []        return self.generateTreesUtil([i+1 for i in range(n)])    def generateTreesUtil(self,nums):        if not nums:            return [None]        if len(nums)==1:            return [TreeNode(nums[0])]        output=[]        for i in range(len(nums)):            left=self.generateTreesUtil(nums[:i])            right=self.generateTreesUtil(nums[i+1:])            for node1 in left:                for node2 in right:                    root=TreeNode(nums[i])                    root.left=node1                    root.right=node2                    output.append(root)        return output    def BSTtoDLink(self,root):        'convert BST to doubly link list - inorderly'        if not root:            return None                headLeft=self.BSTtoDLink(root.left)        headRight=self.BSTtoDLink(root.right)        'we will expect two link list from left and right and then simlpy connect them using the root'        if headLeft:            'we will return head of left linked list'            head=headLeft            while headLeft.right:                headLeft=headLeft.right            'connect using the root'            headLeft.right=root            root.left=headLeft            root.right=headRight            if headRight:                headRight.left=root            return head        else:            'if no left exist when we will return the root'            if headRight:                root.right=headRight                root.left=None                headRight.left=root                return root            else:                return root    def lowestCommonAncestor1(self, root, p, q):        # we are getting the paths that end at p and q        # then the last last common node from the beginning of two lists is the LCA        # a much much simpler version is below        path1=self.pathToNode(root,p)        path2=self.pathToNode(root,q)        output=path1[0]        while path1 and path2:            x,y=path1.pop(0),path2.pop(0)            if x.val!=y.val:                return output            else:                output=x        #if either of the list ends        return  output            def pathToNode(self,root,p):        if not root:            return []        if root.val==p.val:            return [root]        lists1=self.pathToNode(root.left,p)        lists2=self.pathToNode(root.right,p)        if lists1 or lists2:            return [root]+lists1+lists2        else:            return []    def lowestCommonAncestor(self, root, p, q):        # if both elements are greather than the root, then solution is in right tree        # if both elements are smaller than the root, then solution is in left tree        # else the root is the solution, because on element is less(/euql) and other greater(/euql)         if root.val > p.val and root.val > q.val:            return self.lowestCommonAncestor(root.left, p, q)        elif root.val < p.val and root.val < q.val:            return self.lowestCommonAncestor(root.right, p, q)        else:            return root            def successorInorder(self,root,node):        # In Binary Tree, Inorder successor of a node is the next node in Inorder traversal of the Binary Tree. Inorder Successor is NULL for the last node in Inoorder traversal.        # http://www.geeksforgeeks.org/inorder-successor-in-binary-search-tree/        # if node has right subtree then min of right subtree is the successor        if node.right:            curr=node.right            while curr.left:                curr=curr.left            return curr        # otherwise, travel using root pointer until we see a node which is left child of it's root. the root of such a node is the successor        else:            while root:                if node.val<root.val:                    succ=root                    root=root.left                elif node.val>root.val:                    root=root.right                else:                    break            return succtree=BTree1()tree.insertNode(5)tree.insertNode(3)tree.insertNode(2)tree.insertNode(4)tree.insertNode(9)tree.insertNode(8)tree.insertNode(10)##tree1=BTree()##tree1.insertNode(1)##tree1.insertNode(2)##tree1.insertNode(3)##tree1.insertNode(4)##tree1.insertNode(3)##tree1.insertNode(4)##tree1.insertNode(3)root=tree.returnRoot()#root1=tree1.returnRoot()#tree.printTree(root)#print "---"#print tree.printSortedTree(root)#i,v = BSTIterator(None),[]#while i.hasNext():#    v.append(i.next())#print v#tree.numTrees(4)#tree1=BTree1()#print tree1.isValidBST(root)print tree.kthSmallest(root,3)#print tree.numTrees(3)#x=tree.lowestCommonAncestor(root,root.left,root.left.right)#print x.val