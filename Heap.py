# Definition for a binary tree node.class Heap:    # we are creating a min heap here, Array is where elements are stored, index 1 to n, first element is dummy, 2*i will give left child, 2*i+1 right    # use lengthA to keep the length of the Array, if we decrease the lengthA, remember to pop the element from the array    # build heap is O(nlogn) trivially, but tighter bound is O(n)    def __init__(self,size):        self.nums=[None for i in range(size)]        self.size=size    def buildMinHeap(self,nums):        # dummy first element        self.nums=[0]+[num for num in nums]        self.size=len(nums)        # do heapify from the middle entry (all child after the middle entry is already heapfied by definition) to the top entry        for i in range(self.size/2,0,-1):            self.heapify(i)    def heapify(self,i):        # if current element is less than any of left or right child, swap and heapfiy from the swapped positon        min=i        left=2*i        right=(2*i)+1        if left<=self.size and self.nums[left]<nums[i]:            min=left        if right<=self.size and self.nums[right]<self.nums[min]:            min=right        if min!=i:            temp=nums[i]            self.nums[i]=self.nums[min]            self.nums[min]=temp            self.heapify(min)    def extractMin(self):        # swap A[1] with A[lengthA], pop the A[lengthA] and heapify from A[1]        if self.size>0:            min=self.nums[1]            self.nums[1]=self.nums[self.size]            self.size-=1            self.heapify(1)            return min    def printHeap(self):        for x in self.Array[1:]: print x    def shiftUp(self,i):        while i>0 and self.nums[i/2]>self.nums[i]:            temp=self.nums[i/2]            self.nums[i/2]=self.nums[i]            self.nums[i]=temp            i=i/2                def insert(self,val):        # insert at size+1 and do recurive push up using shiftUp        self.size+=1        self.nums[self.size]=val        self.shiftUp(self.size)    def heapSort(self):        # swap first and last element, decrease size and heapify from the first  element to reduced size        # do it until we have at least two elemets        # remember to adjust size-->we are doing this in-place        size=self.size        for i in range(self.size,1,-1):            temp=self.nums[self.size]            self.nums[self.size]=self.nums[1]            self.nums[1]=temp            self.size-=1            self.heapify(1)        self.size=size            def printHeap(self):        print self.nums[1:]        class Solution(object):    # make heap from nums and pop to get the k-th largest, note that as we have a mean heap k-th largest is len(nums)-k+1th smallest    def findKthLargest(self, nums, k):        lenNums=len(nums)        heap=Heap()        heap.buildMinHeap(nums)        for i in range(lenNums-k):            heap.extractMin()        #print A        return heap.extractMin()# There is a big file of words which is dynamically changing. We are continuously adding some words into it. How would you keep track of top 10 trending words at each moment?# Use mean heap and hash map. Mean heap would contain top 10 most trending words, where root is the worst# When a new word is added to the file then: Create a new element x with x.key=word and x.count=1. Add x to the hash-table. O(1). Add x to the mean-heap. O(lgn).# When an existing word is added to the file then: Find x in the hash-table. O(1). Update x.count to x.count++, dupate mean-heap O(logn)# Another similar problem: find k'th largest element in a stram. Use min heap with size k where root is the k'th largest#heap=Heap()#heap.buildHeap([10,2,8,9,7,20,1])#heap.insert(0,7)#print solution.findKthLargest([10,2,8,9,7,20,1],4)#heap.heapSort([10,2,8,9,7,20,1])#heap.printHeap()        