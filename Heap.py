# Definition for a binary tree node.class Heap:    # we are creating a min heap here, Array is where elements are stored, index 1 to n, first element is dummy, 2*i will give left child, 2*i+1 right    # use lengthA to keep the length of the Array, if we decrease the lengthA, remember to pop the element from the array    # build heap is O(nlogn) trivially, but tighter bound is O(n)    def __init__(self):        return        def buildHeap(self,A):        self.Array=A        lengthA=len(A)        # dummy first element        A.insert(0,None)        # do heapify from the middle entry (all child after the middle entry is already heapfied by definition) to the top entry        for i in range(lengthA/2,0,-1):            self.heapify(A,i,lengthA)    def heapify(self,A,i,lengthA):        # if current element is less than any of left or right child, swap and heapfiy from the swapped positon        left=2*i        right=(2*i)+1        min=i        if left<=lengthA and A[left]<A[min]:   min=left        if right<=lengthA and A[right]<A[min]:   min=right        if min!=i:            temp=A[i]            A[i]=A[min]            A[min]=temp            self.heapify(A,min,lengthA)                def popMin(self):        # swap A[1] with A[lengthA], pop the A[lengthA] and heapify from A[1]        A=self.Array        if len(A)==1:            return        if len(A)==2:            return A.pop()                lengthA=len(A)-1        temp=A[1]        A[1]=A[lengthA]        A[lengthA]=temp        lengthA-=1        output=A.pop()               self.heapify(A,1,lengthA)        return output    def insert(self):        # insert at lengthA+1 and do recurive push up    def heapSort(self,A):        # swap A[1] with A[lengthA], decrease lengthA and heapify from A[1] to reduced lengthA        # do it for all elements         lengthA=len(A)        self.buildHeap(A)        m=lengthA        while m>1:            temp=A[1]            A[1]=A[m]            A[m]=temp            m-=1            self.heapify(A,1,m)        return A                def printHeap(self):        for x in self.Array[1:]: print xclass Solution(object):    # make heap from nums and pop to get the k-th largest, note that as we have a mean heap k-th largest is len(nums)-k+1th smallest    def findKthLargest(self, nums, k):        lenNums=len(nums)        heap=Heap()        heap.buildHeap(nums)        for i in range(lenNums-k):            heap.popMin()        #print A        return heap.popMin()# There is a big file of words which is dynamically changing. We are continuously adding some words into it. How would you keep track of top 10 trending words at each moment?# Use mean heap and hash map. Mean heap would contain top 10 most trending words, where root is the worst# When a new word is added to the file then: Create a new element x with x.key=word and x.count=1. Add x to the hash-table. O(1). Add x to the mean-heap. O(lgn).# When an existing word is added to the file then: Find x in the hash-table. O(1). Update x.count to x.count++, dupate mean-heap O(logn)# Another similar problem: find k'th largest element in a stram. Use min heap with size k where root is the k'th largestsolution=Solution()print solution.findKthLargest([10,2,8,9,7,20,1],4)#heap.heapSort([10,2,8,9,7,20,1])#heap.printHeap()        