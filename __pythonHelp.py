# Extended Slices systaxfor tuples,array, listssay L=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]L[0:6] will return [0, 1, 2, 3, 4, 5], this is same as saying L[0:6:1]L[0:6:2] will [0, 2, 4]L[6:0:-1] will [6, 5, 4, 3, 2, 1]simply L[::-1] will return [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]a=a[::-1] will copy reverse of a to aif you have a=[list of nodes in a tree] then x=[root.val for root in a] will give x=[vales of lised tree nodes], this is a very concise way of copysay we want to initialize an array like [0,2,2,2] for this do a=[0]+[num]*how many times# python list insert, delete, min, max O(n), append O(1), sort O(nlogn); dictionaries O(1) for common operations (index, len, del, clear, pop, setdefault), O(n) for iterations# https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt# need infinitely large value? use x=float('inf'), for smaller use x=float('-inf')# for ii,elem in enumerate(a)--> ii wi give the index and elem the corresponding number from a# ''.join(a) will make strings from list a, '/'.join(a) will make strings with / between adjacent elements in a# string can be simply comparabe e,g., "abc"<"acd" will return True# a=list(b) will make a list from b string# try to use + when dealing with list of strings, rather than making each string as list then append/insert something then join again# join and append don't go in one statement e.g., ''.join(a.append('b')) is not possible# to copy a list by value use a=list(b)# sorted(a) sorts the list a, if a  is a string sorted(a) will return a list# reverse a list a.reverse() then use a as a reverse list# "acdf".index("df") will give 2# a.insert(i,10) --> insert 10 at index i of a , a.remove(2) will remove the first 2 from a# sorted(range(len(nums)), key = lambda y: nums[y]) --> returns sorted index order of nums based on the numbers#adder_lambda = lambda parameter1,parameter2: parameter1+parameter2 is similar to following#def adder_regular(parameter1, parameter2): return parameter1+parameter2# http://stackoverflow.com/questions/8966538/syntax-behind-sortedkey-lambda # dict.setdefault(key_val, []).append(val) adding value to a key which value is list# del a[1] will delete key 1 entry from the a dictionary# for k,v in dict,items()--> will give key to k, value to v# dict.keys()-->list of keys, dic.values()-->list of values # dict.get(key,0) will give 0 if key is not there, else return value of the key, we can do simply dict[k]=dict.get(k,0)+1 to increase value by 1 at a key# bin(a) if a is 10 the result is '0b1010'->>bin(a)[2:] is the actual number, int('1010',2) would give the int of binary 1010# chr(ord('a') + 3) -->d# del a[2] deletes #3 elements from a, a.pop() returns (and deletes) last element, a.pop(0) returns (and deletes) first element# a[-1] gives the last element (doesn't pop that)# merging two lists a=a+b# if we write headA.next and headA.next.next, if headA.next exists then  headA.next.next# will execute, will get no error even if headA.next doesn't exist, because in that case then second one will not execute # if-else as an statement b=1 if a==1 else 0# max(a) retuns max of list a , a.index(max(a)) returns max of list a# xrange(1, 10, 2)-->first element to be one, the last element to be one less than ten, and that we'd like each element to go up by two# for example if we have a=[[1],[2]], for b in a:   b.insert(0,11) will result a=[[11,1],[11,2]], call by reference in python  # if a=[1,2] then b=a means, [1,2] is a memory and we are giving two name a,b to that. but if you write b=list(a) or b=a[:], a new copy of a will be created with difference memory  # similaryly, say, a and b are two nodes of a linkedList. b=a means the node which points by a will point by b also, but b=a and a=ListNode(100) means a points to a differnt node no,  # but b points to previos a's pointed memory#st.split() will eliminte words separated by white spaces# st.strip() will remove header and trailer whitespaces# using regular expression we can seperate words by any delimiters, but problems come with white spaces# import re   st=re.sub('\s', '', st) removes all whitespace characters# st=re.split('[\t,;:]',st) will split the st using the delimeters, so can first split by available delimiters and replace all whotespace chars with ''# Sets are lists with no duplicate entries.Sets are implemented in a way, which doesn't allow mutable objects.sets doesn't support indexinga = set(["Jake", "John", "Eric"]) or a={"Jake","John", "Erik"} a.intersection(b) a.union(b) a.add("cde") a.pop() a.remove("Jake")#import random print(random.randint(0,9)) will print a random number from 0 to 9 (including both)Operators:** Exponent, Performs exponential (power) calculation on operators, a**b =10 to the power 20# raising exception: raise Exception("The queue is empty")OOP in Python------------>Enumclass Animal:    DOG = 1    CAT = 2x = Animal.DOGclass status:    office='office'    away='away'class test:    def __init__(self):        self.myenum=status.away  # test class have enum myenumt=test()print t.myenum# in python, there is no public or private keywords>Classclass Vehicle:    def __int__(self,id):        self.id=idclass Car (Vehicle): -->extends/inherits class vehicle, multiple inheritance is allowed e.g., Car(Vehicle,option1)    wheels=4  --> static attribute, can be accesses from anywhere using Car.wheels    def __init__(self, make, model,id="NA"):        Vehicle.__init__(self, id)        self._make = make   --> private attribute        self.model = model  --> public attribute    def make_car_sound():  -->static attribute, can be accesses from anywhere using Car.make_car_sound()        print 'VRooooommmm!'    @staticmethod    def staticmethod():isinstance(mister_pet, Pet) --> checks whether mister_pet is an instance of Pet class        > abstract class from abc import ABCMeta # used for the abstract base classclass Entry:    # this tells us that this is an abstract class    __metaclass__=ABCMeta    