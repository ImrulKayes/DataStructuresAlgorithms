# Definition for a binary tree node.class TreeNode:    def __init__(self,l,h):        self.l=l        self.h=h        self.left = None        self.right = None        self.max=Noneclass Itree:            def insertNode(self,root,l,h):        if not root:            root=TreeNode(l,h)            root.max=h            return root        else:            'max is going all the way to the root'            if l<root.l:                root.left=self.insertNode(root.left,l,h)                root.max=max(root.max,root.left.max)            else:                root.right=self.insertNode(root.right,l,h)                root.max=max(root.max,root.right.max)            return root    def searchConflict(self,root,l,h):        if root.l<=h and l<=root.h:            return (root.l,root.h)        elif not root.left:            return self.searchConflict(root.right,l,h)        'if max of left is less than l or search item go right'        elif l>root.left.max:            return self.searchConflict(root.right,l,h)        else:            return self.searchConflict(root.left,l,h)            def printTree(self,root):        if root is None:            return        else:            print root.l,root.h,root.max            self.printTree(root.left)            self.printTree(root.right)tree=Itree()root=tree.insertNode(None,17,19)tree.insertNode(root,5,8)tree.insertNode(root,21,24)tree.insertNode(root,4,8)tree.insertNode(root,15,18)tree.insertNode(root,7,10)tree.insertNode(root,16,22)tree.printTree(root)print tree.searchConflict(root,21,23)'We have intervals, marge the intervals that are overlapping''sort intervals according to start value. if interval i is not overalpped with i-1 then i+1 will not overlapped with i-1''after sorting scan every interval, if it can be merged to the previous one, then merge them, else push it into the result vector.'class Interval:    def __init__(self,s=0,e=0):        self.start=s        self.end=edef sortIntervals(intervals):    if len(intervals)<=1:        return intervals    mid=len(intervals)/2    left=sortIntervals(intervals[:mid])    right=sortIntervals(intervals[mid:])    output=[]    while left and right:        if left[0].start<=right[0].start:            output.append(left.pop(0))        else:            output.append(right.pop(0))    if left:        output+=left    if right:        output+=right    return outputclass Solution:    def merge(self,intervals):        if len(intervals)<=1:            return intervals                intervals=sortIntervals(intervals)        output=[]        curr=intervals[0]        for i in range(1,len(intervals)):            if intervals[i].start>curr.end:                output.append(curr)                curr=intervals[i]            else:                curr.end=max(intervals[i].end,curr.end)        if output and output[-1]!=curr:            output.append(curr)        else:            output.append(curr)        return output        #for interval in output:            #print interval.start, interval.end    if __name__=="__main__":    solution=Solution()    solution.merge([Interval(1,3),Interval(1,4)])def maximumIntervalOverlap(arr,dep):    'Consider a big party where a log register for guest entry and exit times is maintained.    ' Find the time at which there are maximum guests in the party. Note that entries in register are not in any order. http://www.geeksforgeeks.org/find-the-point-where-maximum-intervals-overlap/'    'similar problem: http://www.geeksforgeeks.org/minimum-number-platforms-required-railwaybus-station/'    'we are sorting arriving and departing times and doing a count using merge as following'        arr=sorted(arr)    dep=sorted(dep)    maxs=float('-inf')    curr=0    i,j=0,0    m,n=len(arr),len(dep)    while i<m and j<n:        'if guest arriaved increment count and update maxs if needed'        if arr[i]<=dep[j]:            curr+=1            i+=1            if curr>maxs:                maxs=curr        'else a guest has left and update count'         else:            curr-=1            j+=1    'still some guests are arrring, they dont left!'    if i<m:        while i<m:            curr+=1            if curr>maxs:                maxs=curr    return maxs    if __name__=="__main__":    print maximumIntervalOverlap([1,2,9,5,5],[4,5,12,9,12])    