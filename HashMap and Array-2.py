class Solution:    def firstNonrepeated1(self, st):        "Given a string, find the first non-repeating character in it."        "two pass solution, an optimization is below, consider the string might be very large"        dic={}        for i in range(len(st)):            dic[st[i]]=dic.get(st[i],0)+1        for char in st:            if dic[char]==1:                return char        return '-1'            def firstNonrepeated(self, st):        "rather than treaversing the string twice, we can treaverse the count dic in the second pass"        dic={}        for i in range(len(st)):            "along with count, we are keeping track when the char is first seen"            if dic.has_key(st[i]):                dic[st[i]]=[dic[st[i]][0]+1,dic[st[i]][1]]            else:                dic[st[i]]=[1,i]        res='-1'        min=float('inf')        "need to find a char with count 1 and least index"        for k,v in dic.iteritems():            if v[0]==1:                if v[1]<min:                    res=k                    min=v[1]        return res        def increasingTriplet(self, nums):        """        Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.        """                c1=c2=float('inf')        for num in nums:            if num<=c1:                c1=num            elif num<=c2:                c2=num            else:                return True        return False        def isValidSudoku(self, board):        """        9*9 matrix, no reapted entries in rows and cols        no repeated entires in all 3*3 cells        """        for i in range(9):            dic={}            for j in range(9):                if board[i][j]!='.':                    if dic.has_key(board[i][j]):                        return False                    else:                        dic[board[i][j]]=1        for j in range(9):            dic={}            for i in range(9):                if board[i][j]!='.':                    if dic.has_key(board[i][j]):                        return False                    else:                        dic[board[i][j]]=1        for block in range(3):            # process 3 blocks with row 0 to 2, then next 3 blocks with tows 3 to 5            # starting rows, 0,3,6            row=block*3            for block1 in range(3):                # starting cols 0,3,6                col=block1*3                dic={}                for i in range(row,row+3):                    for j in range(col,col+3):                        if board[i][j]!='.':                            if dic.has_key(board[i][j]):                                return False                            else:                                dic[board[i][j]]=1                                return True    def longestCommonPrefix(self, strs):        """        Write a function to find the longest common prefix string amongst an array of strings.        """        if not len(strs):            return ""        if len(strs)==1:            return strs[0]        minLen=min([len(str) for str in strs])        count=0        for i in range(minLen):            char=strs[0][i]            for j in range(1,len(strs)):                if strs[j][i]!=char:                    return strs[0][:count]            count+=1        return strs[0][:count]    def addBinary(self, a, b):        """        Two binary a and b as string, add them        intuitive solution below        """        i,j=len(a)-1,len(b)-1        sum=0        c=0        output=[]        while i>=0 and j>=0:            sum=c+int(a[i])+int(b[j])            output.append(str(sum%2))            c=sum/2            i-=1            j-=1        if i>=0:            k=i            while k>=0:                sum=c+int(a[k])                output.append(str(sum%2))                c=sum/2                k-=1            if j>=0:            k=j            while k>=0:                sum=c+int(b[k])                output.append(str(sum%2))                c=sum/2                k-=1           if c==1:            output.append('1')        return ''.join(output)[::-1]    def lengthOfLastWord(self, s):        """        return the lenght of last word in string s, might be leading and trailing zeros        """        if not s:            return 0        for i in range(len(s)-1,-1,-1):            if s[i]!=' ':                break        for j in range(i,-1,-1):            if s[j]==' ':                return len(s[j+1:i+1])        return len(s[j:i+1])    def isPalindrome(self, s):        """        palindrome, only consider alphaneumaric        """        if not s:            return True        s=s.lower()        s1=[]        for x in s:            if (x>='a' and x<='z') or (x>='0' and x<='9'):                s1.append(x)        mid=len(s1)/2        for i in range(mid):            if s1[i]!=s1[len(s1)-1-i]:                return False        return True    def strStr(self, haystack, needle):        """        find first index of needle in haystack        """        if not needle:            return 0        if not haystack:            return -1        for i in range(len(haystack)-(len(needle)-1)):            if haystack[i:i+len(needle)]==needle:                return i        return -1                def findSubArray(self,nums,target):        "In an Array, find the Contiguous Subarray with Sum to a Given Value."        "keep two pointers, increse front if more elements needed, adjust tail if sum is greater"                if not nums:    return []        head,tail=0,0        currSum=0        while head<len(nums):            if currSum==target:                return nums[tail:head]            elif currSum>target:                currSum-=nums[tail]                tail+=1            else:                currSum+=nums[head]                head+=1        return []                def nextGreaterElement(self,nums):        # Given an array, print the Next Greater Element (NGE) for every element.        # The Next greater Element for an element x is the first greater element on the right side of x in array. Elements for which no greater element exist, consider next greater element as -1.        # solution: push first element in a stack, for rest of the element if the element is geater than top of the stack pop all of the elements that are smaller, for them the element in the next greater        # otherwise push the element in the stack, finally the elements remain in the stack have no next, so set -1 in output                if not nums:    return        q=[nums[0]]        for i in range(1,len(nums)):            next=nums[i]            if q:                if q[-1]<next:                    print q[-1],next                    q.pop()                    while q and q[-1]<next:                        print q[-1],next                        q.pop()                    q.append(next)                else:                    q.append(next)            else:                q.append(next)        if q:            for num in q:                print num,-1                    def canPair(self,nums,k):        "Given an array of integers and a number k, write a function that returns true if given array can be divided into pairs such that sum of every pair is divisible by k."        # If length of given array is odd or none, return false. An odd length array cannot be divided in pairs.        if not nums or len(nums)%2==1:            return False        freq={}        # count number of unique reminders        for num in nums:            if freq.has_key(num%k):                freq[num%k]+=1            else:                freq[num%k]=1        for num in nums:            rem=num%k            # if reminder is half k, then should be even (e.g., consider 5,5,5,5 and k=10)            if rem==k/2:                if freq[rem]%2!=0:                    return False            # otherwise             elif freq[rem]!=freq[k-rem]:                return False            else:                pass        return True        def minDist(self,nums,x,y):        # http://www.geeksforgeeks.org/find-the-minimum-distance-between-two-numbers/        # Given an unsorted array arr[] and two numbers x and y, find the minimum distance between x and y in arr[].        # The array might also contain duplicates. You may assume that both x and y are different and present in arr[].        if not nums:    return        mindist='Inf'        prev='Inf'        #Find the first occurence of any of the two numbers (x or y) and store the index of this occurence in prev        for i in range(len(nums)):            if nums[i]==x or nums[i]==y:                prev=i                break        #Traverse after the first occurence        for j in range(i,len(nums)):            #If the current element matches with any of the two then            #check if current element and prev element are different            #Also check if this value is smaller than minimum distance so far            if nums[j]==x or nums[j]==y:                if nums[j]!=nums[prev] and (j-prev)<mindist:                    mindist=j-prev                    prev=j                else:                    prev=j        return mindist    def segNums(self,nums):        # You are given an array of 0s and 1s in random order. Segregate 0s on left side and 1s on right side of the array. Traverse array only once.        if len(nums)==0 or len(nums)==1:            return        low,high=0,len(nums)-1        while low<high:            # Increment left index while we see 0 at left            while nums[low]!=1 and low<high:                low+=1            # Decrement right index while we see 1 at right            while nums[high]!=0 and low<high:                high-=1            # If left is smaller than right then there is a 1 at left and a 0 at right.  Exchange nums[high] and arr[row]            if low<high:                nums[low]=0                nums[high]=1                low+=1                high-=1        return nums        def minSubArrayLen(self, s, nums):        'given n positive numbers and s, find min length subarry such that sums>=s'        'sort and start collecting elements from the back O(nlogn), a better solution is below'        b=sorted(nums)        print b        sum=0        count=0        for i in xrange(len(b)-1,-1,-1):            sum+=nums[i]            count+=1            if sum>=s:                return count        return 0    # also try to solve it by DP    def minSubArrayLen(self, s, nums):        # given n positive numbers and s, find min length subarry such that sums>=s        # keep two pointers, current one adds new element, if sums>=s adjust minLength by incrementing first pointer to the nextest element where also sums>=s         minLen, total, start = len(nums) + 1, 0, 0        for i in range(len(nums)):            total += nums[i]            while total >=  s:                minLen=min(i - start + 1, minLen)                total-= nums[start]                start+=1        return 0 if minLen > len(nums) else minLen                    solution=Solution()#print solution.findSubArray([25, 12, 14, 22, 19, 15, 10, 23],55)#solution.nextGreaterElement([11, 13, 21, 3])#print solution.canPair([92, 75, 65, 48, 45, 35],10)#print solution.minDist([3, 5, 4, 2, 6, 3, 0, 0, 5, 4, 8, 3],3,6)#print solution.segNums([0, 1, 0, 1, 1, 1])def hightestWaster(nums):    #Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. http://www.geeksforgeeks.org/trapping-rain-water/    # for each bar calculate higher left and right bar including itself    # water trapper in a num is equal to min(left[i],right[i])-nums[i]        left=[nums[i] for i in range(len(nums))]    right=[nums[i] for i in range(len(nums))]    for i in range(1,len(nums)):        left[i]=max(left[i-1],nums[i])    for i in range(len(nums)-2,-1,-1):        right[i]=max(right[i+1],nums[i])    waterVolume=0    for i in range(len(nums)):        waterVolume+=min(left[i],right[i])-nums[i]    return waterVolume#print hightestWaster([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])