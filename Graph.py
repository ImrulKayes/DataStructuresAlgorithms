# Definition for a undirected graph node, use this or simply use an adjacency listclass UndirectedGraphNode:    def __init__(self, x):        self.label = x        self.neighbors = []class Solution:    # @param node, a undirected graph node    # @return a undirected graph node    def cloneGraph(self, node):        if node == None:            return None        queue = [node]        nodeMap = {}        newNode = UndirectedGraphNode(node.label)        nodeMap[node.label] = newNode        while queue:            curr = queue.pop(0)            for neighbor in curr.neighbors:                if not nodeMap.has_key(neighbor.label):                    queue.append(neighbor)                    nodeMap[neighbor.label] = UndirectedGraphNode(neighbor.label)                nodeMap[curr.label].neighbors.append(nodeMap[neighbor.label])        return newNode    def canFinish(self, numCourses, prerequisites):    # topological sorts (https://en.wikipedia.org/wiki/Topological_sorting), if possible then True else False. OJ allowed multiple same edges, this took me one hour to figure out    # note, iterating dictionary and mutating should be cumbersome        dic={}        l=[]        s=[]        count=0        # for each key, values are the nodes that incoming to the key, multiple same edges has been taken once        for alist in prerequisites:            if dic.has_key(alist[1]):                if alist[0] not in dic[alist[1]]:                    dic[alist[1]].append(alist[0])            else:                dic.setdefault(alist[1],[]).append(alist[0])        # add all nodes with no incoming edges to s        for i in range(numCourses):            if not dic.has_key(i):                s.append(i)        # we use count to save some time, len of dictionary or deletion in dictionary takes times        # we are taking one node from s and removing all the edges that are incoming to it        # if any node has no incoming edges we are puting it to the queue        while s:            node=s.pop()            count+=1            l.append(node)            for node1,lists in dic.iteritems():                if node in lists:                    dic[node1].remove(node)                    if len(dic[node1])==0:                        s.append(node1)        print l[::-1]        return count==numCourses    def BFS(self,graph,root):        # visited defines the nodes already discovered        visited={}        for node in graph:            visited[node]=False        q=[root]        visited[root]=True                while q:            node=q.pop(0)            print node            for neighbor in graph[node]:                if not visited[neighbor]:                    q.append(neighbor)                    visited[neighbor]=True    def buildGraph(self,edges):        graph={}        for edge in edges:            graph.setdefault(edge[0],[]).append(edge[1])            graph.setdefault(edge[1],[]).append(edge[0])        return graph        def DFS(self,graph,root):        visited={}               for node in graph:            visited[node]=False        q=[root]                        while q:            node=q.pop()            if not visited[node]:                visited[node]=True                print node                for neighbor in graph[node][::-1]:                    q.append(neighbor)    def dfsRecursive(self,graph,root):        visited={}        for node in graph:            visited[node]=False        self.dfsUtil(graph,visited,root)    def dfsUtil(self,graph,visited,root):        if not visited[root]:            print root            visited[root]=True            for neighbor in graph[root]:                 self.dfsUtil(graph,visited,neighbor)        solution=Solution()#print solution.canFinish(4, [[1,0],[2,0],[3,1],[3,2]])#graph=solution.buildGraph([[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]])#solution.BFS(graph,1)#solution.dfsRecursive(graph,1)#solution.DFS(graph,1)'''Cycle detection using DFS in a directed graph'''def createGraph(edges):    graph={}    for edge in edges:        graph.setdefault(edge[0],[]).append(edge[1])    return graphdef isCycleUtil(graph,visited,rStack,node,res,temp):    # if an element is visited before and it is in recursive stack then cycle found    if visited[node] and rStack[node]:        res+=temp[:]        return True    else:               visited[node]=True        rStack[node]=True        # if the node has no outgoing edges        if not graph.has_key(node):            rStack[node]=False            # no recureence for this node, unset it's rStack            return False        else:            for neighbor in graph[node]:                if isCycleUtil(graph,visited,rStack,neighbor,res,temp+[node]):                        return True            # all recurrences are done for this node and no cycle found, unset rStack for the node and return False            rStack[node]=False            return False        def isCycle(graph,source):    # we need to used rStack to keep track which element are in the recursive stack    # if an element is visited before and it is in recursive stack then cycle found    # e.g., ['a','b'],['a','c'],['b','d'],['c','d'],['d','e'] for c, it's neighbor d has been visited before but it's not in the recursive stack, so no cycle eventually    visited={}    rStack={}    for node,neighbors in graph.iteritems():        visited[node]=False        rStack[node]=False        # some nodes have no outgoing edes, for them also visited should be False        for neighbor in neighbors:            visited[neighbor]=False    res=[]    temp=[]    print isCycleUtil(graph,visited,rStack,source,res,temp)    print res##if __name__=="__main__":##    graph=createGraph([['a','b'],['a','c'],['b','d'],['c','d'],['d','a']])##    isCycle(graph,'a')        '''Topological sort'''def buildGraph(edges):    # buid a graph from edges if a->b then b is depended on a, so b has a list which contains a    graph={}    for edge in edges:        graph.setdefault(edge[1],[]).append(edge[0])    # there are nodes which are not dependent on anyone, for them empty list    for edge in edges:        if not graph.has_key(edge[0]):            graph[edge[0]]=[]    return graphdef topologicalSort1(graph):    # another implementation is below    output=[]    while graph:        noSort=True        for node in graph:            # if a node has indegree zero            if not graph[node]:                output.append(node)                noSort=False                # delete all the edges outgoing from the node                for node1 in graph:                    if node1!=node:                        for i in range(len(graph[node1])):                            if graph[node1][i]==node:                                graph[node1].pop(i)                # this break indicates at least one such indegree zero node has been got                # we need to delete that node before we proceed, but as we have used dictionary we cant iterate and delete at the same time                # so we will detete it later after break                break        if noSort:            return []        del graph[node]            return outputdef topologicalSort(graph):    # s contains the nodes who have no incoming edges    output=[]    s=[]    for k in graph:        if not graph[k]:            s.append(k)    while s:        node=s.pop()        output.append(node)        del graph[node]        for node1,lists in graph.iteritems():            if node in lists:                lists.remove(node)            if not lists:                s.append(node1)    if graph:   return []    return output                                                              #if __name__=="__main__":#    graph=buildGraph([['a','b'],['b','c'],['c','d']])#    print topologicalSort(graph) '''Alien language: Given a sorted dictionary of an alien language, find order of charactersFor example ["baa", "abcd", "abca", "cab", "cad"] would result ['b', 'd', 'a', 'c'], beacuse the dic is sorted and in "baa", "abcd"-->b is before a, "abcd", "abca"--->d should before a'''def createGraphAlien(words):    'Create a dependence graph, consider two consequtive words, add an edge between characteres first mismatched'    graph={}    for i in range(1,len(words)):        j,k=0,0        while j<len(words[i-1]) and k<len(words[i]):            if words[i-1][j]!=words[i][k]:                break            j+=1            k+=1        if j<len(words[i-1]) and k<len(words[i]):            'words[i-1][k] is dependent on words[i][k]'            graph.setdefault(words[i][k],[]).append(words[i-1][j])    'get the chars who are dependednt on no one.'    independentNodes=[]    for k,v in graph.iteritems():        for v1 in v:            if not graph.has_key(v1):                'we can can change the dictionary on the fly, so keeping track of the chars'                independentNodes.append(v1)    for v in v1:        graph[v1]=[]    return graph        if __name__=="__main__":    graph=createGraphAlien(["baa", "abcd", "abca", "cab", "cad"])    print topologicalSort(graph) 