# Definition for a undirected graph node, use this or simply use an adjacency listclass UndirectedGraphNode:    def __init__(self, x):        self.label = x        self.neighbors = []class Solution:    # @param node, a undirected graph node    # @return a undirected graph node    def cloneGraph(self, node):        if node == None:            return None        queue = [node]        nodeMap = {}        newNode = UndirectedGraphNode(node.label)        nodeMap[node.label] = newNode        while queue:            curr = queue.pop(0)            for neighbor in curr.neighbors:                if not nodeMap.has_key(neighbor.label):                    queue.append(neighbor)                    nodeMap[neighbor.label] = UndirectedGraphNode(neighbor.label)                nodeMap[curr.label].neighbors.append(nodeMap[neighbor.label])        return newNode    def canFinish(self, numCourses, prerequisites):    # topological sorts (https://en.wikipedia.org/wiki/Topological_sorting), if possible then True else False. OJ allowed multiple same edges, this took me one hour to figure out    # note, iterating dictionary and mutating should be cumbersome        dic={}        l=[]        s=[]        count=0        # for each key, values are the nodes that incoming to the key, multiple same edges has been taken once        for alist in prerequisites:            if dic.has_key(alist[1]):                if alist[0] not in dic[alist[1]]:                    dic[alist[1]].append(alist[0])            else:                dic.setdefault(alist[1],[]).append(alist[0])        # add all nodes with no incoming edges to s        for i in range(numCourses):            if not dic.has_key(i):                s.append(i)        # we use count to save some time, len of dictionary or deletion in dictionary takes times        # we are taking one node from s and removing all the edges that are incoming to it        # if any node has no incoming edges we are puting it to the queue        while s:            node=s.pop()            count+=1            l.append(node)            for node1,lists in dic.iteritems():                if node in lists:                    dic[node1].remove(node)                    if len(dic[node1])==0:                        s.append(node1)        print l[::-1]        return count==numCourses    def BFS(self,graph,root):        visited={}        for node in graph:            visited[node]=False        q=[root]        visited[root]=True                while q:            node=q.pop(0)            print node            for neighbor in graph[node]:                if not visited[neighbor]:                    q.append(neighbor)                    visited[neighbor]=True    def buildGraph(self,edges):        graph={}        for edge in edges:            graph.setdefault(edge[0],[]).append(edge[1])            graph.setdefault(edge[1],[]).append(edge[0])        return graph        def DFS(self,graph,root):        visited={}               for node in graph:            visited[node]=False        q=[root]                        while q:            node=q.pop()            if not visited[node]:                visited[node]=True                print node                for neighbor in graph[node][::-1]:                    q.append(neighbor)    def dfsRecursive(self,graph,root):        visited={}        for node in graph:            visited[node]=False        self.dfsUtil(graph,visited,root)    def dfsUtil(self,graph,visited,root):        if not visited[root]:            print root            visited[root]=True            for neighbor in graph[root]:                 self.dfsUtil(graph,visited,neighbor)        solution=Solution()#print solution.canFinish(4, [[1,0],[2,0],[3,1],[3,2]])#graph=solution.buildGraph([[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]])#solution.BFS(graph,1)#solution.dfsRecursive(graph,1)#solution.DFS(graph,1)